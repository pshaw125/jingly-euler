package com.rhejinald.euler.problems;

import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.fail;

public class Problem12 {
    /**
     * Problem 12 - HighlyDivisibleTriangularNumber
     * <p>
     * <p>
     * problem: the sequence of triangle numbers is generated by adding the natural numbers.
     * So the 7th tirangle number = 1+2+3+4+5+6+7=28
     * First 10 terms would be 1,3,6,10,15,21,28,36,45,55
     * <p>
     * Factors:
     * 1: 1
     * 3: 1,3
     * 6: 1,2,3,6
     * 10: 1,2,5,10
     * 15: 1,3,5,15
     * 21: 1,3,7,21
     * 28: 1,2,4,7,14,28
     * <p>
     * 28 is the first triangle number to have over 5 divisors
     * <p>
     * What is the first triangle number to have over 500 divisors?
     */

    @Test
    public void problem() {

        final List<Long> triangleNumbers = getTriangleNumbers(13000);

        long mostFactors = 0l;
        long bestNumber = 0l;

        for (Long triangleNumber : triangleNumbers) {
            final Set<Long> factors = getFactors(triangleNumber);
            if (factors.size() > 500) {
                System.out.println("number" + triangleNumber);
                System.out.println("factor count " + factors.size());
                return;
            }
            if (factors.size() > mostFactors) {
                mostFactors = factors.size();
                bestNumber = triangleNumber;
            }
        }

        fail("not found :(" +
                "Best so far: " + bestNumber + "(" + mostFactors + ")");
    }


    @Test
    public void testGetFactors() throws Exception {
        assertThat(getFactors(1)).containsOnly(1l);
        assertThat(getFactors(3)).containsOnly(1l, 3l);
        assertThat(getFactors(6)).containsOnly(1l, 2l, 3l, 6l);
        assertThat(getFactors(10)).containsOnly(1l, 2l, 5l, 10l);
        assertThat(getFactors(15)).containsOnly(1l, 3l, 5l, 15l);
        assertThat(getFactors(21)).containsOnly(1l, 3l, 7l, 21l);
        assertThat(getFactors(28)).containsOnly(1l, 2l, 4l, 7l, 14l, 28l);
    }

    @Test
    public void testGetTriangleNumber() throws Exception {
        assertThat(getTriangleNumbers(2)).containsOnly(1l, 3l);
        assertThat(getTriangleNumbers(5)).containsOnly(1l, 3l, 6l, 10l, 15l);
        final List<Long> triangleNumbers10 = getTriangleNumbers(10);
        assertThat(triangleNumbers10).containsOnly(1l, 3l, 6l, 10l, 15l, 21l, 28l, 36l, 45l, 55l);
        assertThat(triangleNumbers10.get(triangleNumbers10.size() - 1)).isEqualTo(55l);
    }

    @Test
    public void testIsFactor() throws Exception {
        assertThat(isFactor(1l, 1l)).isTrue();
        assertThat(isFactor(1l, 2l)).isFalse();
        assertThat(isFactor(10l, 1l)).isTrue();
        assertThat(isFactor(10l, 2l)).isTrue();
        assertThat(isFactor(10l, 5l)).isTrue();
        assertThat(isFactor(10l, 10l)).isTrue();
        assertThat(isFactor(10l, 9l)).isFalse();
        assertThat(isFactor(10l, 3l)).isFalse();
        assertThat(isFactor(26l, 6l)).isFalse();
        assertThat(isFactor(26l, 5l)).isFalse();
        assertThat(isFactor(26l, 4l)).isFalse();
        assertThat(isFactor(25l, 5l)).isTrue();

    }

    @Test
    public void testGetDivisorResult() throws Exception {
        assertThat(getDivisorResult(4, 2)).isEqualTo(2l);
        assertThat(getDivisorResult(10, 5)).isEqualTo(2l);
        assertThat(getDivisorResult(10, 10)).isEqualTo(1l);
        assertThat(getDivisorResult(10, 1)).isEqualTo(10l);

    }

    private List<Long> getTriangleNumbers(int count) {
        final ArrayList<Long> numbers = Lists.newArrayList();
        long runningTotal = 0;
        for (int i = 1; i <= count; i++) {
            runningTotal += i;
            numbers.add(runningTotal);
        }
        return numbers;
    }

    private Set<Long> getFactors(long number) {
        final double sqrt = Math.floor(Math.sqrt(number));
        Set<Long> knownFactors = Sets.newHashSet();
        for (long divisor = 1; divisor <= sqrt; divisor++) {
            if (isFactor(number, divisor)) {
                knownFactors.add(divisor);
                knownFactors.add(getDivisorResult(number, divisor));
            }
        }
        return knownFactors;
    }

    private long getDivisorResult(long number, long divisor) {
        return number / divisor;
    }

    private boolean isFactor(long number, long divisor) {
        return number == divisor
                || number >= divisor
                && number % divisor == 0;
    }


}
